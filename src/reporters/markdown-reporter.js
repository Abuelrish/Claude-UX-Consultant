/**
 * Markdown Reporter
 * Generates developer-friendly documentation in Markdown format
 */

const fs = require('fs').promises;

class MarkdownReporter {
  async generate(analysisResults, options = {}) {
    const outputPath = options.outputPath || `./reports/ux-analysis-${Date.now()}.md`;
    
    const markdown = this.generateMarkdown(analysisResults);
    await fs.writeFile(outputPath, markdown);
    
    return outputPath;
  }

  generateMarkdown(data) {
    const url = new URL(data.url);
    const hostname = url.hostname;
    
    return `# üéØ UX Analysis Report - ${hostname}

**Generated by:** Claude UX Consultant  
**Date:** ${new Date().toLocaleString()}  
**URL:** ${data.url}  
**Analysis Type:** ${data.analysisType || 'Standard'}  
**Analysis Time:** ${data.analysisTime || 'N/A'}  

---

## üìä Executive Summary

### Overall Score: ${data.summary?.overallScore || 0}/100

**üéØ Key Findings:**
- **Total Issues:** ${data.issues?.length || 0}
- **Critical Issues:** ${data.summary?.criticalIssues || 0}
- **Recommendations:** ${data.recommendations?.length || 0}
- **Estimated Fix Time:** ${data.summary?.estimatedFixTime || 0} minutes

${this.generateScoreBreakdown(data)}

---

${this.generatePriorityActions(data)}

${this.generateIssuesSection(data)}

${this.generateRecommendationsSection(data)}

${this.generateMetricsSection(data)}

${this.generateScoresSection(data)}

${this.generateComplianceSection(data)}

${this.generateImplementationGuide(data)}

${this.generateNextSteps(data)}

---

## üîß Technical Details

### Analysis Configuration
- **Viewport:** 1920x1080 (Desktop)
- **User Agent:** Claude-UX-Consultant/1.0
- **Timeout:** 30 seconds
- **Screenshot:** ${data.screenshots?.length > 0 ? 'Captured' : 'Not captured'}

### Tools Used
- **Browser Automation:** Playwright
- **Accessibility:** Local implementation (WCAG 2.1)
- **Performance:** Navigation Timing API
- **Visual Analysis:** Computed Styles API
- **Mobile Testing:** Responsive viewport simulation

---

## üìö Resources

### WCAG Guidelines
- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [WebAIM Accessibility Resources](https://webaim.org/resources/)

### Performance Resources
- [Core Web Vitals](https://web.dev/vitals/)
- [Web Performance Working Group](https://www.w3.org/webperf/)

### Mobile Guidelines
- [Mobile Web Best Practices](https://www.w3.org/TR/mobile-bp/)
- [Touch Target Guidelines](https://www.w3.org/WAI/WCAG21/Understanding/target-size.html)

---

## üìû Support

For questions about this analysis or Claude UX Consultant:
- **GitHub:** [Claude UX Consultant](https://github.com/Abuelrish/Claude-UX-Consultant)
- **Documentation:** [User Guide](https://github.com/Abuelrish/Claude-UX-Consultant/docs)

---

*This analysis was generated using Claude UX Consultant v1.0.0*  
*Report ID: ${this.generateReportId(data)}*`;
  }

  generateScoreBreakdown(data) {
    if (!data.scores || Object.keys(data.scores).length === 0) return '';
    
    let breakdown = '### Score Breakdown\n\n';
    
    Object.entries(data.scores).forEach(([category, score]) => {
      const emoji = this.getScoreEmoji(score);
      breakdown += `- **${this.formatCategoryName(category)}:** ${score}${typeof score === 'number' ? '/100' : ''} ${emoji}\n`;
    });
    
    return breakdown + '\n';
  }

  generatePriorityActions(data) {
    if (!data.summary?.priorityActions || data.summary.priorityActions.length === 0) {
      return '';
    }
    
    let section = '## üî• Priority Actions\n\n';
    section += '**These issues require immediate attention:**\n\n';
    
    data.summary.priorityActions.forEach((action, index) => {
      section += `### ${index + 1}. ${action.title}\n\n`;
      section += `**Description:** ${action.description}\n\n`;
      section += `**Action Required:** ${action.action}\n\n`;
      section += `**Impact:** ${action.impact}\n\n`;
      section += '---\n\n';
    });
    
    return section;
  }

  generateIssuesSection(data) {
    if (!data.issues || data.issues.length === 0) {
      return '## ‚úÖ No Issues Found\n\nGreat job! No major issues were detected in this analysis.\n\n';
    }
    
    let section = '## üö® Issues Found\n\n';
    
    // Group issues by severity
    const grouped = this.groupBy(data.issues, 'severity', 'impact');
    
    ['critical', 'high', 'medium', 'low'].forEach(severity => {
      if (grouped[severity] && grouped[severity].length > 0) {
        section += `### ${this.getSeverityEmoji(severity)} ${this.formatSeverity(severity)} Issues\n\n`;
        
        grouped[severity].forEach((issue, index) => {
          section += `#### ${index + 1}. ${issue.title}\n\n`;
          section += `**Description:** ${issue.description}\n\n`;
          section += `**Fix:** ${issue.fix || issue.solution || 'See description'}\n\n`;
          
          if (issue.category) {
            section += `**Category:** ${issue.category}\n\n`;
          }
          
          if (issue.wcag) {
            section += `**WCAG Reference:** ${issue.wcag}\n\n`;
          }
          
          if (issue.count) {
            section += `**Affected Elements:** ${issue.count}\n\n`;
          }
          
          section += '---\n\n';
        });
      }
    });
    
    return section;
  }

  generateRecommendationsSection(data) {
    if (!data.recommendations || data.recommendations.length === 0) {
      return '';
    }
    
    let section = '## üí° Recommendations\n\n';
    
    // Group recommendations by category
    const grouped = this.groupBy(data.recommendations, 'category', 'type');
    
    Object.entries(grouped).forEach(([category, recs]) => {
      if (recs.length > 0) {
        section += `### ${this.getCategoryEmoji(category)} ${this.formatCategoryName(category)}\n\n`;
        
        recs.forEach((rec, index) => {
          section += `#### ${index + 1}. ${rec.title}\n\n`;
          section += `**Description:** ${rec.description}\n\n`;
          section += `**Suggestion:** ${rec.suggestion || rec.fix || 'See description'}\n\n`;
          section += `**Impact:** ${rec.impact || 'Medium'}\n\n`;
          
          if (rec.effort) {
            section += `**Effort:** ${rec.effort}\n\n`;
          }
          
          section += '---\n\n';
        });
      }
    });
    
    return section;
  }

  generateMetricsSection(data) {
    if (!data.metrics || Object.keys(data.metrics).length === 0) {
      return '';
    }
    
    let section = '## üìà Metrics\n\n';
    section += '| Metric | Value |\n';
    section += '|--------|-------|\n';
    
    Object.entries(data.metrics).forEach(([key, value]) => {
      section += `| ${this.formatMetricName(key)} | ${value} |\n`;
    });
    
    section += '\n';
    return section;
  }

  generateScoresSection(data) {
    if (!data.scores || Object.keys(data.scores).length === 0) {
      return '';
    }
    
    let section = '## üéØ Detailed Scores\n\n';
    
    Object.entries(data.scores).forEach(([category, score]) => {
      const percentage = typeof score === 'number' ? Math.min(score, 100) : 0;
      const bar = this.generateProgressBar(percentage);
      
      section += `### ${this.formatCategoryName(category)}\n\n`;
      section += `**Score:** ${score}${typeof score === 'number' ? '/100' : ''}\n\n`;
      section += `**Progress:** ${bar}\n\n`;
      section += this.getScoreDescription(category, score) + '\n\n';
      section += '---\n\n';
    });
    
    return section;
  }

  generateComplianceSection(data) {
    let section = '## ‚úÖ Compliance Assessment\n\n';
    
    // WCAG Compliance
    const accessibilityIssues = (data.issues || []).filter(issue => 
      issue.type === 'accessibility' || issue.wcag
    );
    
    section += '### WCAG 2.1 Compliance\n\n';
    if (accessibilityIssues.length === 0) {
      section += '‚úÖ **Status:** Likely AA Compliant\n\n';
      section += '**Violations:** None detected\n\n';
    } else {
      section += '‚ùå **Status:** Non-compliant\n\n';
      section += `**Violations:** ${accessibilityIssues.length} accessibility issues found\n\n`;
    }
    
    // Mobile Compliance
    const mobileIssues = (data.issues || []).filter(issue => issue.type === 'mobile');
    
    section += '### Mobile Responsiveness\n\n';
    if (mobileIssues.length === 0) {
      section += '‚úÖ **Status:** Mobile-friendly\n\n';
    } else {
      section += '‚ö†Ô∏è **Status:** Mobile issues detected\n\n';
      section += `**Issues:** ${mobileIssues.length} mobile-specific problems\n\n`;
    }
    
    // Performance Compliance
    section += '### Performance Standards\n\n';
    if (data.metrics?.loadTime) {
      const loadTime = data.metrics.loadTime;
      if (loadTime <= 2000) {
        section += '‚úÖ **Load Time:** Excellent (‚â§2s)\n\n';
      } else if (loadTime <= 3000) {
        section += '‚ö†Ô∏è **Load Time:** Good (‚â§3s)\n\n';
      } else {
        section += '‚ùå **Load Time:** Needs improvement (>3s)\n\n';
      }
    }
    
    return section;
  }

  generateImplementationGuide(data) {
    if (!data.issues || data.issues.length === 0) return '';
    
    let section = '## üîß Implementation Guide\n\n';
    
    section += '### Quick Wins (Easy to implement)\n\n';
    const quickWins = data.recommendations?.filter(r => r.effort === 'low' || r.impact === 'quick') || [];
    
    if (quickWins.length > 0) {
      quickWins.slice(0, 5).forEach((rec, index) => {
        section += `${index + 1}. **${rec.title}** - ${rec.suggestion || rec.fix}\n`;
      });
      section += '\n';
    } else {
      section += 'No quick wins identified. Focus on addressing critical issues first.\n\n';
    }
    
    section += '### Development Priorities\n\n';
    section += '1. **Critical Issues** - Address immediately (blocks functionality)\n';
    section += '2. **High Priority** - Include in current sprint\n';
    section += '3. **Medium Priority** - Plan for next sprint\n';
    section += '4. **Low Priority** - Include in future releases\n\n';
    
    section += '### Testing Checklist\n\n';
    section += '- [ ] Test on mobile devices (iOS Safari, Android Chrome)\n';
    section += '- [ ] Verify keyboard navigation works throughout\n';
    section += '- [ ] Check color contrast with tools like WebAIM\n';
    section += '- [ ] Test with screen readers (NVDA, VoiceOver)\n';
    section += '- [ ] Validate performance with Lighthouse\n';
    section += '- [ ] Cross-browser testing (Chrome, Firefox, Safari, Edge)\n\n';
    
    return section;
  }

  generateNextSteps(data) {
    let section = '## üöÄ Next Steps\n\n';
    
    if (data.summary?.criticalIssues > 0) {
      section += `### Immediate Actions (This Week)\n\n`;
      section += `üö® **Fix ${data.summary.criticalIssues} critical issues** - These are blocking user functionality\n\n`;
    }
    
    if (data.summary?.highIssues > 0) {
      section += `### Sprint Planning (Next 2 Weeks)\n\n`;
      section += `üî¥ **Address ${data.summary.highIssues} high-priority issues** - Include in current development cycle\n\n`;
    }
    
    if (data.summary?.quickWins > 0) {
      section += `### Quick Improvements (Ongoing)\n\n`;
      section += `‚ö° **Implement ${data.summary.quickWins} quick wins** - Low effort, high impact improvements\n\n`;
    }
    
    section += '### Continuous Monitoring\n\n';
    section += '1. **Set up automated UX monitoring** - Run analysis weekly\n';
    section += '2. **Monitor performance metrics** - Track Core Web Vitals\n';
    section += '3. **Regular accessibility audits** - Monthly comprehensive checks\n';
    section += '4. **User feedback integration** - Connect analysis results with user reports\n\n';
    
    section += '### Tools for Ongoing Quality\n\n';
    section += '```bash\n';
    section += '# Quick analysis during development\n';
    section += 'claude-ux quick http://localhost:3000\n\n';
    section += '# Pre-deployment comprehensive check\n';
    section += 'claude-ux deep https://staging.example.com\n\n';
    section += '# Production monitoring\n';
    section += 'claude-ux monitor https://example.com --interval 300\n';
    section += '```\n\n';
    
    return section;
  }

  // Helper methods
  groupBy(array, ...keys) {
    return array.reduce((grouped, item) => {
      const key = keys.find(k => item[k]) ? item[keys.find(k => item[k])] : 'other';
      if (!grouped[key]) grouped[key] = [];
      grouped[key].push(item);
      return grouped;
    }, {});
  }

  getSeverityEmoji(severity) {
    const emojis = {
      'critical': 'üö®',
      'high': 'üî¥',
      'medium': 'üü°',
      'low': 'üîµ'
    };
    return emojis[severity] || '‚ö™';
  }

  getCategoryEmoji(category) {
    const emojis = {
      'accessibility': '‚ôø',
      'performance': '‚ö°',
      'visual': 'üé®',
      'mobile': 'üì±',
      'bug': 'üêõ',
      'seo': 'üîç'
    };
    return emojis[category] || 'üìã';
  }

  getScoreEmoji(score) {
    if (typeof score !== 'number') return '';
    if (score >= 90) return 'üü¢';
    if (score >= 70) return 'üü°';
    if (score >= 50) return 'üü†';
    return 'üî¥';
  }

  formatSeverity(severity) {
    return severity.charAt(0).toUpperCase() + severity.slice(1);
  }

  formatCategoryName(name) {
    return name
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  }

  formatMetricName(name) {
    return name
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  }

  generateProgressBar(percentage) {
    const filled = Math.round(percentage / 5);
    const empty = 20 - filled;
    return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty) + ` ${percentage}%`;
  }

  getScoreDescription(category, score) {
    if (typeof score !== 'number') return '';
    
    const descriptions = {
      accessibilityScore: {
        90: 'Excellent accessibility compliance',
        70: 'Good accessibility with minor issues', 
        50: 'Moderate accessibility concerns',
        0: 'Significant accessibility barriers'
      },
      performanceScore: {
        90: 'Outstanding performance',
        70: 'Good performance with optimization opportunities',
        50: 'Average performance needing improvement',
        0: 'Poor performance requiring immediate attention'
      }
    };
    
    const categoryDescriptions = descriptions[category] || {};
    const threshold = Object.keys(categoryDescriptions)
      .map(Number)
      .sort((a, b) => b - a)
      .find(t => score >= t);
    
    return categoryDescriptions[threshold] || 'Score needs improvement';
  }

  generateReportId(data) {
    const url = new URL(data.url);
    const timestamp = Date.now();
    return `${url.hostname.replace(/\./g, '-')}-${timestamp}`;
  }
}

module.exports = MarkdownReporter;